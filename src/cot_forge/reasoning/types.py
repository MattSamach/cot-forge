"""
This module defines the core data structures for representing reasoning processes,
including the `ReasoningNode` and `SearchResult` classes.
`ReasoningNode` represents a single step in a chain of thought, storing information
about the strategy used, the prompt, the response, the chain of thought (CoT) data,
parent and child nodes, and metadata. It also provides methods for traversing the
reasoning tree and extracting the complete CoT.
`SearchResult` encapsulates the outcome of a reasoning search, including the final
reasoning node, the question, the ground truth answer, all terminal nodes, the success
status, the final answer, and any relevant metadata.
"""

from typing import Any, Optional

from cot_forge.reasoning.strategies import Strategy
from cot_forge.utils.parsing import extract_final_answer_from_cot

# TODO: Add write to file method for SearchResult


class ReasoningNode:
    """
    A node in a reasoning graph/tree/chain representing a step in the reasoning process.
    Attributes:
        strategy (Strategy | None): The strategy applied at this node.
        prompt (str): The prompt used to generate the response.
        response (str): The response generated by the prompt.
        cot (list[dict[str, Any]] | None): Chain of thought steps for this node. 
            Each step is a dictionary.
        parent (Optional['ReasoningNode']): The parent node in the reasoning chain.
        children (list[ReasoningNode]): The child nodes of this node.
        is_final (bool): Indicates if this node is the final node in its chain.
        success (bool): Indicates if the reasoning at this node was successful.
        metadata (dict[str, Any]): Additional information about this node.
    Methods:
        add_child(child: 'ReasoningNode'): Adds a child node to this node.
        get_full_node_chain(): Returns the complete chain of nodes from the root to this node.
        get_full_cot(): Returns the complete chain of thought from the root to this node.
    """
    def __init__(self, 
             strategy: Strategy | None,
             prompt: str,
             response: str,
             cot: list[dict[str, Any]] | None = None,  # Changed from dict to list[dict]
             parent: Optional['ReasoningNode'] = None,
             metadata: dict[str, Any] = None,
             ):
        self.strategy = strategy
        self.prompt = prompt
        self.response = response
        self.cot: dict[str, Any] = cot
        self.parent = parent
        self.children: list[ReasoningNode] = []
        self.is_final = False
        self.success = False
        self.metadata = {} if metadata is None else metadata

    def add_child(self, child: 'ReasoningNode'):
        self.children.append(child)
        
    def get_full_node_chain(self) -> list['ReasoningNode']:
        """Get the complete chain from the root to this node."""
        chain = []
        current_node = self
        while current_node:
            chain.append(current_node)
            current_node = current_node.parent
        return list(reversed(chain))
    
    def get_full_cot(self) -> list[dict[str, Any]]:
        """Get the complete chain of thought (CoT) from the root to this node."""
        nodes = self.get_full_node_chain()  # Already in root-to-current order
        result = []
        for node in nodes:
            if node.cot:
                result.extend(node.cot)
        return result
    
    def __repr__(self):
        return (f"ReasoningNode(strategy={self.strategy}, ",
                f"prompt={self.prompt}, response={self.response}, "
                f"cot={self.cot}, parent={self.parent}, "
                f"children={self.children}, is_final={self.is_final}, "
                f"success={self.success}, metadata={self.metadata})")
    
    def __str__(self):
        return (f"ReasoningNode(strategy={self.strategy}, ",
                f"prompt={self.prompt}, response={self.response}, "
                f"cot={self.cot}, parent={self.parent}, "
                f"children={self.children}, is_final={self.is_final}, "
                f"success={self.success}, metadata={self.metadata})")

class SearchResult:
    """
    Represents the outcome of a search process for a reasoning task.
    Attributes:
        question (str): The original question posed to the search algorithm.
        ground_truth_answer (str): The known correct answer to the question, if available.
        terminal_nodes (list[ReasoningNode] | None): A list of all terminal nodes reached in search.
        success (bool): Indicates whether the search was successful in finding a valid answer.
        metadata (dict[str, Any]): Additional information or statistics about the search process.
    """
    
    def __init__(
        self,
        question: str = "",
        ground_truth_answer: str = "",
        terminal_nodes: list[ReasoningNode] | None = None,
        success: bool = False,
        metadata: dict[str, Any] = None
    ):
        self.question = question
        self.ground_truth_answer = ground_truth_answer
        self.terminal_nodes = terminal_nodes if terminal_nodes else []
        self.success = success
        self.metadata = metadata if metadata else {}
        
    # let's get fucked up! (Continue from here, get rid of all places where final_node and final_answer are used.)
    # Also, change terminal_nodes to terminal_nodes, be more concise bozo) Ya dork! 
    # just kidding, I love you! not really, but I do love this code.
        
    def get_successful_terminal_nodes(self) -> list[ReasoningNode]:
        """Returns a list of successful terminal nodes."""
        return [node for node in self.terminal_nodes if node.success]
    
    def get_successful_final_answers(self) -> list[str]:
        """Returns a list of final answers from successful terminal nodes."""
        return [extract_final_answer_from_cot(node.cot) for node in self.get_successful_terminal_nodes()]
    
    def get_all_final_answers(self) -> list[str]:
        """Returns a list of all final answers from terminal nodes."""
        return [extract_final_answer_from_cot(node.cot) for node in self.terminal_nodes]
        
    def __repr__(self):
        return (f"SearchResult(question={self.question!r}, "
                f"ground_truth_answer={self.ground_truth_answer!r}, "
                f"terminal_nodes={self.terminal_nodes}, "
                f"success={self.success}, "
                f"successful_nodes={len(self.get_successful_terminal_nodes())}, "
                f"metadata={self.metadata})")

    def __str__(self):
        successful_answers = self.get_successful_final_answers()
        return (f"SearchResult(success={self.success}, "
                f"question={self.question!r}, "
                f"num_terminal_nodes={len(self.terminal_nodes)}, "
                f"num_successful_nodes={len(self.get_successful_terminal_nodes())}, "
                f"successful_answers={successful_answers})")
