"""
This module defines the core data structures for representing reasoning processes,
including the `ReasoningNode` and `SearchResult` classes.
`ReasoningNode` represents a single step in a chain of thought, storing information
about the strategy used, the prompt, the response, the chain of thought (CoT) data,
parent and child nodes, and metadata. It also provides methods for traversing the
reasoning tree and extracting the complete CoT.
`SearchResult` encapsulates the outcome of a reasoning search, including the final
reasoning node, the question, the ground truth answer, all terminal nodes, the success
status, the final answer, and any relevant metadata.
"""

from typing import Any, Optional

from cot_forge.reasoning.strategies import Strategy

# TODO: Change final_answer to a method with list of answers
# TODO: Change final_node to method of list of successful terminal nodes
# TODO: Add write to file method for SearchResult


class ReasoningNode:
    """
    A node in a reasoning graph/tree/chain representing a step in the reasoning process.
    Attributes:
        strategy (Strategy | None): The strategy applied at this node.
        prompt (str): The prompt used to generate the response.
        response (str): The response generated by the prompt.
        cot (list[dict[str, Any]] | None): Chain of thought steps for this node. 
            Each step is a dictionary.
        parent (Optional['ReasoningNode']): The parent node in the reasoning chain.
        children (list[ReasoningNode]): The child nodes of this node.
        is_final (bool): Indicates if this node is the final node in its chain.
        success (bool): Indicates if the reasoning at this node was successful.
        metadata (dict[str, Any]): Additional information about this node.
    Methods:
        add_child(child: 'ReasoningNode'): Adds a child node to this node.
        get_full_node_chain(): Returns the complete chain of nodes from the root to this node.
        get_full_cot(): Returns the complete chain of thought from the root to this node.
    """
    def __init__(self, 
             strategy: Strategy | None,
             prompt: str,
             response: str,
             cot: list[dict[str, Any]] | None = None,  # Changed from dict to list[dict]
             parent: Optional['ReasoningNode'] = None,
             metadata: dict[str, Any] = None,
             ):
        self.strategy = strategy
        self.prompt = prompt
        self.response = response
        self.cot: dict[str, Any] = cot
        self.parent = parent
        self.children: list[ReasoningNode] = []
        self.is_final = False
        self.success = False
        self.metadata = {} if metadata is None else metadata

    def add_child(self, child: 'ReasoningNode'):
        self.children.append(child)
        
    def get_full_node_chain(self) -> list['ReasoningNode']:
        """Get the complete chain from the root to this node."""
        chain = []
        current_node = self
        while current_node:
            chain.append(current_node)
            current_node = current_node.parent
        return list(reversed(chain))
    
    def get_full_cot(self) -> list[dict[str, Any]]:
        """Get the complete chain of thought (CoT) from the root to this node."""
        nodes = self.get_full_node_chain()  # Already in root-to-current order
        result = []
        for node in nodes:
            if node.cot:
                result.extend(node.cot)
        return result
    
    def __repr__(self):
        return (f"ReasoningNode(strategy={self.strategy}, ",
                f"prompt={self.prompt}, response={self.response}, "
                f"cot={self.cot}, parent={self.parent}, "
                f"children={self.children}, is_final={self.is_final}, "
                f"success={self.success}, metadata={self.metadata})")
    
    def __str__(self):
        return (f"ReasoningNode(strategy={self.strategy}, ",
                f"prompt={self.prompt}, response={self.response}, "
                f"cot={self.cot}, parent={self.parent}, "
                f"children={self.children}, is_final={self.is_final}, "
                f"success={self.success}, metadata={self.metadata})")

class SearchResult:
    """
    Represents the outcome of a search process for a reasoning task.
    Attributes:
        question (str): The original question posed to the search algorithm.
        ground_truth_answer (str): The known correct answer to the question, if available.
        final_node (ReasoningNode | None): The terminal node reached by the search algorithm.
        all_terminal_nodes (list[ReasoningNode] | None): A list of all terminal nodes reached in search.
        success (bool): Indicates whether the search was successful in finding a valid answer.
        final_answer (Optional[str]): The answer derived from the final reasoning node, if available.
        metadata (dict[str, Any]): Additional information or statistics about the search process.
    """
    
    def __init__(
        self,
        question: str = "",
        ground_truth_answer: str = "",
        final_node: ReasoningNode | None = None,
        all_terminal_nodes: list[ReasoningNode] | None = None,
        success: bool = False,
        final_answer: Optional[str] = None,
        metadata: dict[str, Any] = None
    ):
        self.final_node = final_node
        self.question = question
        self.ground_truth_answer = ground_truth_answer
        self.all_terminal_nodes = all_terminal_nodes if all_terminal_nodes else []
        self.success = success
        self.final_answer = final_answer
        self.metadata = metadata if metadata else {}
        
    def __repr__(self):
        return (f"SearchResult(question={self.question!r}, "
                f"ground_truth_answer={self.ground_truth_answer!r}, "
                f"final_node={self.final_node}, "
                f"all_terminal_nodes={self.all_terminal_nodes}, "
                f"success={self.success}, "
                f"final_answer={self.final_answer!r}, "
                f"metadata={self.metadata})")

    def __str__(self):
        return (f"SearchResult(success={self.success}, "
                f"final_answer={self.final_answer!r}, "
                f"question={self.question!r}, "
                f"num_terminal_nodes={len(self.all_terminal_nodes)})")
